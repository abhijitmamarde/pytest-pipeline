# -*- coding: utf-8 -*-
"""
    pytest_pipeline.core
    ~~~~~~~~~~~~~~~~~~~~

    Core pipeline test classes.

    :copyright: (c) 2014 Wibowo Arindrarto <bow@bow.web.id>
    :license: BSD

"""

import os
import shlex
import subprocess
import sys
import threading
import time
from uuid import uuid4

import pytest

from . import mark


class PipelineRun(object):

    def __init__(self, cmd, stdout=sys.stdout, stderr=sys.stderr,
                 poll_time=0.01, timeout=None):
        self.cmd = cmd
        self.stdout = stdout
        self.stderr = stderr
        self.poll_time = poll_time
        self.timeout = float(timeout) if timeout is not None else timeout
        self._process = None
        self._toks = shlex.split(cmd)

    def __repr__(self):
        return "{0}(...)".format(self.__class__.__name__)

    @property
    def run_id(self):
        if not hasattr(self, "_run_id"):
            self._run_id = str(uuid4())
        return self._run_id

    @property
    def exit_code(self):
        if self._process is not None:
            return self._process.returncode

    def launch_process_and_wait(self):

        def target():
            self._process = subprocess.Popen(self._toks, stdout=self.stdout,
                                             stderr=self.stderr)
            while self._process.poll() is None:
                time.sleep(self.poll_time)

        if isinstance(self.stdout, basestring):
            self.stdout = open(self.stdout, "w")
        elif self.stdout is None:
            self.stdout = open(os.devnull, "w")

        if isinstance(self.stderr, basestring):
            self.stderr = open(self.stderr, "w")
        elif self.stderr is None:
            self.stderr = open(os.devnull, "w")

        thread = threading.Thread(target=target)
        thread.start()

        thread.join(self.timeout)
        if thread.is_alive():
            self._process.terminate()
            pytest.fail("Process is taking longer than {0} seconds".format(self.timeout))


class MetaPipelineTest(type):

    def __init__(cls, name, bases, dct):
        # TODO: ensure only subclasses of PipelineTest gets this custom __init__
        cls.test_id = str(uuid4())
        cls.test_dirname = cls.__name__ + "_" + cls.test_id
        cls = pytest.mark.usefixtures("_autogenerated_test_dir")(cls)
        cls._before_runs = []
        cls._before_runs_done = []
        # make sure existing _before_runs attribs from subclasses are appended
        for base in bases:
            cls._before_runs.extend(getattr(base, "_before_runs", []))
            cls._before_runs_done.extend(getattr(base, "_before_runs_done", []))

        for attr, val in dct.iteritems():

            if attr == "run" and not isinstance(val, PipelineRun):
                raise ValueError("Test class '{0}' does not have a proper "
                                 "'run' attribute".format(cls))

            if not callable(val) or not hasattr(val, "_pipeline"):
                continue

            dct[attr] = pytest.mark.xfail_pipeline(val)

            if not val._pipeline.get("phase") == mark.BEFORE_RUN:
                continue

            # TODO: can we also add non-test items to this list?
            #       current problem now is it won't be run since
            #       we use pytests's plugin hook to reorder
            cls._before_runs.append(val)
            if attr.startswith("test_"):
                # HACK: consider the item 'done' if it's non-test
                cls._before_runs_done.append(not attr.startswith("test_"))

        super(MetaPipelineTest, cls).__init__(name, bases, dct)


class PipelineTest(object):

    __metaclass__ = MetaPipelineTest

    def __repr__(self):
        return "{0}(id='{1}', ...)".format(self.__class__.__name__, self.test_id)

    def _run_before_run_methods(self):
        if not all(self._before_runs_done):
            for idx, bfunc in enumerate(self._before_runs):
                bfunc(self)
                self._before_runs_done[idx] = True
